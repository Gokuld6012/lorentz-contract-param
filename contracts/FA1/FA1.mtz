let {

  type Param =
    ( (Address, Nat)              %transfer
    | View () Nat                 %getTotalSupply
    | View Address Nat            %getBalance
    );

  type Store = (BigMap Address Nat, Nat);

  getSourceBalance :: '[(Address, Nat), Store]
                   -> '[Nat, (Address, Nat), Store]
  = {duup; car; source; get; assert_some; };

  newSourceBalance :: '[Nat, (Address, Nat), Store]
                   -> '[Option Nat, (Address, Nat), Store]
  = { duup; cdr; swap; sub; dup; assert_ge;
      dup; eq; if {drop; none Nat} {isnat};
    };

  debitSource :: '[Option Nat, (Address, Nat), Store] -> '[(Address, Nat), Store]
  = { dip {swap; unpair}; source; update; pair; swap};

  getRecipientBalance :: '[(Address, Nat), Store]
                      -> '[Option Nat, (Address, Nat), Store]
  = { duup; car; duup; car; get};

  newRecipientBalance :: '[Option Nat, (Address, Nat), Store]
                      -> '[Nat, (Address, Nat), Store]
  = { if_some
      {duup; cdr; add}
      {dup; cdr};
    };

  creditRecipient :: '[Nat, (Address, Nat), Store]
                  -> '[(Address, Nat), Store]
  = { some; duup; car; diip {swap; unpair}; update; pair; swap;};

  transferBalance :: '[(Address, Nat), Store]
                  -> '[(List Operation, Store)]
  = { getSourceBalance; newSourceBalance; debitSource;
      getRecipientBalance; newRecipientBalance; creditRecipient;
      drop; nil operation; pair;
    };

  getTotalSupply :: '[ View () Nat, Store ] -> '[(List Operation, Store)]
  = { view {cddr} };

  getBalance :: '[ View Address Nat, Store ]
             -> '[(List Operation, Store)]
  = { view { unpair; dip {car}; get; if_some {} {push nat 0} } };

};
parameter Param;
storage Store;
code {unpair;
      case
        { transferBalance}
        { getTotalSupply }
        { getBalance };
     };
