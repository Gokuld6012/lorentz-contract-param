let {
  type CounterParameter = (Unit | Unit | Nat | View Unit Nat | Void Unit Bytes);

  toCounter :: '[Parameter, Storage]
            -> '[(List Operation, Storage)]
  = { car; dip {self}; pair;
      tag 3 CounterParameter;
      dip {dup; car; contract CounterParameter; assert_some; amount};
      transfer_tokens;
      nil operation; swap; cons;
      dip {car; sender; some; swap; pair}; pair
    };

  toCaller :: '[Nat, Parameter, Storage]
           -> '[(List Operation, Storage)]
  = { left unit;
      dip {drop; dup; cdr; assert_some; contract (Nat | Unit); assert_some; amount; };
      transfer_tokens;
      nil operation; swap; cons;
      dip {car; none address; swap; pair}; pair
    };


};
parameter (Unit, Option Nat);
storage (Address %counter, Option %caller Address);
code { unpair; dup; cdr; if_some {toCaller} {toCounter};}
