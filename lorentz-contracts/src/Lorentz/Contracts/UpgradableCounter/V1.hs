module Lorentz.Contracts.UpgradableCounter.V1
  ( UpgradableStorageSkeleton(..)
  , UpgradableInterfaceSkeleton(..)
  , migrate
  , counterContract
  , getUField_counterValue  -- Used when migrating to the next version
  ) where

import Lorentz

import Lorentz.Contracts.Upgradable.Common

-- Currently ignored
data UpgradableStorageSkeleton = UpgradableStorageSkeleton
  { counterValue :: Natural
  }

-- Currently ignored
data UpgradableInterfaceSkeleton
  = Add Natural
  | Mul Natural
  | GetCounterValue (View () Natural)

-- getUField_* are supposed to be autogenerated
--   from UpgradableStorageSkeleton
getUField_counterValue :: UStorage ': s :-> Natural ': UStorage ': s
getUField_counterValue = do
  getUField @Natural [mt|#counterValue|]
  assertSome [mt|Inconsistent storage|]

-- setUField_* are supposed to be autogenerated
--   from UpgradableStorageSkeleton
setUField_counterValue :: Natural ': UStorage ': s :-> UStorage ': s
setUField_counterValue = setUField [mt|#counterValue|]

runAdd :: Natural ': '[UStorage] :-> '[([Operation], UStorage)]
runAdd = do
  dip getUField_counterValue
  add
  setUField_counterValue
  nil; pair

runMul :: Natural ': '[UStorage] :-> '[([Operation], UStorage)]
runMul = do
  dip getUField_counterValue
  mul
  setUField_counterValue
  nil; pair

runView :: View () Natural ': '[UStorage] :-> '[([Operation], UStorage)]
runView = view_ $ do
  cdr
  getUField_counterValue
  dip drop

-- It would be nice if the migration routine type-safety was enforced as well,
--   i.e it was enforced that migrate in fact implements the transformation
--   (empty storage skeleton) -> V1.UpgradableStorageSkeleton (but still
--   has type UStorage -> UStorage). I (@kkirka) don't know how to enforce it
--   and wherther it is at all possible.
migrate :: MigrationScript
migrate = do
  push @Natural 0
  setUField_counterValue

counterContract :: ContractCode
counterContract = do
  -- This dispatch call (or most probably its substitute) is supposed
  --   to be autogenerated from UpgradableInterfaceSkeleton, or statically
  --   typechecked to prevent incorrect unpacks
  dispatch $
    [ ifArg @Natural [mt|Add|] runAdd
    , ifArg @Natural [mt|Mul|] runMul
    , ifArg @(View () Natural) [mt|GetCounterValue|] runView
    ]
