module Lorentz.Contracts.UpgradableCounter.V2
  ( UpgradableInterfaceSkeleton(..)
  , UStoreV2
  , migrate
  , counterContract
  ) where

import Lorentz

import Lorentz.UStore
import Lorentz.Contracts.Upgradable.Common
import Lorentz.Contracts.UpgradableCounter.V1 (UStoreV1)

data UStoreTemplate = UStoreTemplate
  { newCounterValue :: UStoreField Integer
  } deriving stock (Eq, Generic)

type UStoreV2 = UStore UStoreTemplate

-- Currently ignored
data UpgradableInterfaceSkeleton
  = Inc ()
  | Dec ()
  | GetCounterValue (View () Integer)

addInt :: Integer -> '[(), UStoreV2] :-> '[([Operation], UStoreV2)]
addInt x = do
  drop
  ustoreGetField #newCounterValue
  push x
  add
  ustoreSetField #newCounterValue
  nil; pair

runInc :: '[(), UStoreV2] :-> '[([Operation], UStoreV2)]
runInc = addInt 1

runDec :: '[(), UStoreV2] :-> '[([Operation], UStoreV2)]
runDec = addInt (-1)

runView :: '[View () Integer, UStoreV2] :-> '[([Operation], UStoreV2)]
runView = view_ $ do
  cdr
  ustoreGetField #newCounterValue
  dip drop

-- | This function migrates the storage from UStoreV1 to UStoreV2 through an
--   untyped representation (UStore_). Currently it is not type-safe. See
--   /docs/upgradeableContracts.md for type-safe migrations idea description.
--   The result is expected to adhere to V2.UStoreTemplate.
migrate :: MigrationScript
migrate = do
  coerce_ @UStore_ @UStoreV1
  ustoreGetField #counterValue
  int
  dip $ coerce_ @UStoreV1 @UStoreV2
  ustoreSetField #newCounterValue
  coerce_ @UStoreV2 @UStore_
  unsafeDeleteField [mt|counterValue|]
  where
    unsafeDeleteField fieldName = do
      ensureFieldExists fieldName
      none; push fieldName; pack; update
    ensureFieldExists fieldName = do
      dup; push fieldName; pack; get
      assertSome $ mconcat [[mt|Broken migrartion|], fieldName]; drop

counterContract :: ContractCode
counterContract = do
  -- This dispatch call (or most probably its substitute) is supposed
  --   to be autogenerated from UpgradableInterfaceSkeleton, or statically
  --   typechecked to prevent incorrect unpacks
  dispatch $
    [ ifArg @() [mt|Inc|] runInc
    , ifArg @() [mt|Dec|] runDec
    , ifArg @(View () Integer) [mt|GetCounterValue|] runView
    ]
