module Lorentz.Contracts.UpgradableCounter.V2
  ( UpgradableStorageSkeleton(..)
  , UpgradableInterfaceSkeleton(..)
  , migrate
  , counterContract
  ) where

import Lorentz

import Lorentz.Contracts.Upgradable.Common
import qualified Lorentz.Contracts.UpgradableCounter.V1 as V1

-- Currently ignored
data UpgradableStorageSkeleton = UpgradableStorageSkeleton
  { newCounterValue :: Integer
  }

-- Currently ignored
data UpgradableInterfaceSkeleton
  = Add Natural
  | Mul Natural
  | GetCounterValue (View () Integer)

-- getUField_* are supposed to be autogenerated
--   from UpgradableStorageSkeleton
getUField_newCounterValue :: UStorage ': s :-> Integer ': UStorage ': s
getUField_newCounterValue = do
  getUField @Integer [mt|#counterValue|]
  assertSome [mt|Inconsistent storage|]

-- setUField_* are supposed to be autogenerated
--   from UpgradableStorageSkeleton
setUField_newCounterValue :: Integer ': UStorage ': s :-> UStorage ': s
setUField_newCounterValue = setUField [mt|#counterValue|]

runInc :: '[(), UStorage] :-> '[([Operation], UStorage)]
runInc = do
  drop
  getUField_newCounterValue
  push @Integer 1
  add
  setUField_newCounterValue
  nil; pair

runDec :: '[(), UStorage] :-> '[([Operation], UStorage)]
runDec = do
  drop
  getUField_newCounterValue
  push @Integer (-1)
  add
  setUField_newCounterValue
  nil; pair

runView :: View () Integer ': '[UStorage] :-> '[([Operation], UStorage)]
runView = view_ $ do
  cdr
  getUField_newCounterValue
  dip drop

-- It would be nice if the migration routine type-safety was enforced as well,
--   i.e it was enforced that migrate in fact implements the transformation
--   V1.UpgradableStorageSkeleton -> V2.UpgradableStorageSkeleton (but still
--   has type UStorage -> UStorage). I (@kkirka) don't know how to enforce it
--   and wherther it is at all possible.
migrate :: MigrationScript
migrate = do
  V1.getUField_counterValue
  toInteger
  setUField_newCounterValue
  deleteUField_counterValue
  where
    toInteger = push @Integer 0 >> add
    deleteUField_counterValue = do
      none; push [mt|counterValue|]; update

counterContract :: ContractCode
counterContract = do
  -- This dispatch call (or most probably its substitute) is supposed
  --   to be autogenerated from UpgradableInterfaceSkeleton, or statically
  --   typechecked to prevent incorrect unpacks
  dispatch $
    [ ifArg @() [mt|Inc|] runInc
    , ifArg @() [mt|Dec|] runDec
    , ifArg @(View () Integer) [mt|GetCounterValue|] runView
    ]
